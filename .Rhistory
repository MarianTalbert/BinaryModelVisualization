install.packages("Rccp")
install.packages("Rcpp")
library(devtools)
library(Rccp)
library(Rcpp)
library(rInside)
install.packages("rInside")
install.packages("rzmq")
install.packages("rzmq")
install.pacakges("rzmq")
library(rzmq)
install.packages("svSocket")
library(svSocket)
startSocketServer()
## Connect with the R socket server
con <- socketConnection(host = "localhost", port = 50002, blocking = FALSE)
sendSocketClients("Test")
sendSocketClients(Test)
L <- 10:20
L
evalServer(con, L)
writeLines("Test",con)
writeLines("Test",con)
writeLines("{'action':'clear_screens'}",con)
writeLines('{"action":"clear_screens"}',con)
writeLines('{"action":"clear_screens"}',con)
library(caret)
install.packages("caret")
library(caret)
install.packages("pbkrtest")
install.packages("installr")
updateR()
library(installr)
updateR()
install.package("caret")
install.packages("caret")
library(caret)
data(iris)
TrainData <- iris[,1:4]
TrainClasses <- iris[,5]
knnFit <- train(TrainData, TrainClasses, "knn")
knnImp <- varImp(knnFit)
dotPlot(knnImp)
install.package("e1071")
install.packages("e1071")
library(e1071)
data(iris)
TrainData <- iris[,1:4]
TrainClasses <- iris[,5]
knnFit <- train(TrainData, TrainClasses, "knn")
knnImp <- varImp(knnFit)
dotPlot(knnImp)
getModelInfo()
data(iris)
TrainData <- iris[,1:4]
TrainClasses <- iris[,5]
knnFit1 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
tuneLength = 10,
trControl = trainControl(method = "cv"))
knnFit2 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
tuneLength = 10,
trControl = trainControl(method = "boot"))
predict(knnFit1)
?predict
setwd("C:\\GoogleDrive\\Interactive\\Rcode\\Shiny\\MyCode")
ShinyCode<-file.path(getwd(),"ResponseCurves\\External")
sourceList<-list.files(ShinyCode,full.names=TRUE)
unlist(lapply(as.list(sourceList),source))
ChkLibs(list("rgeos","maptools","randomForest","mgcv","dismo","shiny","earth","PresenceAbsence",
"wesanderson","ggplot2","raster","grid","gridExtra","splines","RColorBrewer","plotly","viridis"))
#=====================================================
# This is almost directly from the dismo vignette
files <- list.files(path=paste(system.file(package="dismo"),
'/ex', sep=''), pattern='grd', full.names=TRUE)
files<-files[c(1,5,2,7)]
files<-files[-c(9)]
layerStk <- stack(files)
plot(layerStk)
data(wrld_simpl)
file <- paste(system.file(package="dismo"), "/ex/bradypus.csv", sep="")
bradypus <- read.table(file, header=TRUE, sep=",")
# we do not need the first column
bradypus <- bradypus[,-1]
#And now plot:
# first layer of the RasterStack
plot(layerStk, 1)
# note the "add=TRUE" argument with plot
plot(wrld_simpl, add=TRUE)
# with the points function, "add" is implicit
points(bradypus, col="blue")
presvals <- extract(layerStk, bradypus)
# setting random seed to always create the same
# random set of points for this example
set.seed(0)
#setting up an extent around the presence points
PresExt <- extent(-104.7,-36,-26,16)
backgr <- randomPoints(layerStk,ext=PresExt, 500)
colnames(backgr)<-c("lon","lat")
absvals <- extract(layerStk, backgr)
pb <- c(rep(1, nrow(presvals)), rep(0, nrow(absvals)))
sdmdata <- data.frame(rbind(bradypus,backgr),cbind(pb, rbind(presvals, absvals)))
head(sdmdata)
library(caret)
library(MASS)
library(mlbench)
library(rpart)
TrainData <- sdmdata[,4:7]
TrainClasses <- factor(sdmdata[,3])
createFolds(factor(sdmdata[,3]),
k=5)
set.seed(1)
inTrain<-createDataPartition()
knnFit1 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
tuneLength = 10,
trControl = trainControl(method = "cv"))
knnFit2 <- train(TrainData, TrainClasses,
method = "knn",
preProcess = c("center", "scale"),
tuneLength = 10,
trControl = trainControl(method = "boot"))
nnetFit <- train(TrainData, TrainClasses,
method = "nnet",
preProcess = "range",
tuneLength = 2,
trace = FALSE,
maxit = 100)
lmFit <- train(TrainData, TrainClasses,
method = "glm")
earthFit <- train(TrainData, TrainClasses,
method = "bagEarthGCV")
rdaFit<-train(TrainData,TrainClasses,method="rda")
GLM_Model = glm(pb ~ bio1 + bio5 + bio12+ bio7, data=sdmdata,family=binomial)
MARS_Model = earth(pb~ bio1 + bio5 + bio12 + bio7, data=sdmdata,glm=list(family=binomial))
fitLst<-list(nneFit=nnetFit,knnFit=knnFit1,glmFit=glmFit,earthFit=earthFit,
MARS_Model=MARS_Model,glmFit=glmFit)
fitLst2<-list(GLM_Model=GLM_Model,MARS_Model=MARS_Model,glmFit=glmFit,earthFit=earthFit,
nneFit=nnetFit,knnFit=knnFit1)
glmFit <- train(TrainData, TrainClasses,
method = "glm")
fitLst<-list(nneFit=nnetFit,knnFit=knnFit1,glmFit=glmFit,earthFit=earthFit,
MARS_Model=MARS_Model,glmFit=glmFit)
fitLst2<-list(GLM_Model=GLM_Model,MARS_Model=MARS_Model,glmFit=glmFit,earthFit=earthFit,
nneFit=nnetFit,knnFit=knnFit1)
exploreCurves(fitLst2,inputLayers=layerStk,data=sdmdata,threshold=2,boundary=wrld_simpl)
sourceList
sourceList<-list.files(ShinyCode,full.names=TRUE)
unlist(lapply(as.list(sourceList),source))
fitLst2<-list(GLM_Model=GLM_Model,MARS_Model=MARS_Model,glmFit=glmFit,earthFit=earthFit,
nneFit=nnetFit,knnFit=knnFit1)
exploreCurves(fitLst2,inputLayers=layerStk,data=sdmdata,threshold=2,boundary=wrld_simpl)
data(BloodBrain)
set.seed(1)
str(logBBB)
tmp <- createDataPartition(logBBB,
p = .8,
times = 10)
str(tmp)
rpartFit <- train(bbbDescr, logBBB,
"rpart",
tuneLength = 16,
trControl = trainControl(
method = "LGOCV", index = tmp))
str(rpartFit)
TrainClasses
tmp <- createDataPartition(TrainClasses,
p = .8,
times = 10)
str(tmp)
?train
train
getMethod(train)
getMethod("train")
rpartFit <- train(TrainData, TrainClasses,
method = "glm",
trControl = trainControl(
method = "auc", index = tmp))
str(rpartFit)
?resample
# A demonstration of clicking, hovering, and brushing
shinyApp(
ui = basicPage(
fluidRow(
column(width = 4,
plotOutput("plot", height=300,
click = "plot_click",  # Equiv, to click=clickOpts(id="plot_click")
hover = hoverOpts(id = "plot_hover", delayType = "throttle"),
brush = brushOpts(id = "plot_brush")
),
h4("Clicked points"),
tableOutput("plot_clickedpoints"),
h4("Brushed points"),
tableOutput("plot_brushedpoints")
),
column(width = 4,
verbatimTextOutput("plot_clickinfo"),
verbatimTextOutput("plot_hoverinfo")
),
column(width = 4,
wellPanel(actionButton("newplot", "New plot")),
verbatimTextOutput("plot_brushinfo")
)
)
),
server = function(input, output, session) {
data <- reactive({
input$newplot
# Add a little noise to the cars data so the points move
cars + rnorm(nrow(cars))
})
output$plot <- renderPlot({
d <- data()
plot(d$speed, d$dist)
})
output$plot_clickinfo <- renderPrint({
cat("Click:\n")
str(input$plot_click)
})
output$plot_hoverinfo <- renderPrint({
cat("Hover (throttled):\n")
str(input$plot_hover)
})
output$plot_brushinfo <- renderPrint({
cat("Brush (debounced):\n")
str(input$plot_brush)
})
output$plot_clickedpoints <- renderTable({
# For base graphics, we need to specify columns, though for ggplot2,
# it's usually not necessary.
res <- nearPoints(data(), input$plot_click, "speed", "dist")
if (nrow(res) == 0)
return()
res
})
output$plot_brushedpoints <- renderTable({
res <- brushedPoints(data(), input$plot_brush, "speed", "dist")
if (nrow(res) == 0)
return()
res
})
}
)
source("C:\\GoogleDrive\\Interactive\\Rcode\\Shiny\\MyCode\\ResponseCurves\\external\\ggpairs.R")
library(grid)
library(splines)
#Using the biomod data
dat<-myBiomodData@data.env.var
dat$resp<-as.factor(myBiomodData@data.species)
#using the dismo data
dat<-sdmdata[,c(4:7,3)]
dat[,ncol(dat)]<-as.factor(dat[,ncol(dat)])
correlationViewer(sdmdata,layerStk)
source('C:/GoogleDrive/Interactive/Rcode/Shiny/MyCode/ResponseCurves/external/correlationViewer.r')
correlationViewer(sdmdata,layerStk)
source('C:/GoogleDrive/Interactive/Rcode/Shiny/MyCode/ResponseCurves/external/correlationViewer.r')
correlationViewer(sdmdata,layerStk)
input$plot_brush
?train
rpartFit <- train(TrainData, TrainClasses,
method = "glm",
trControl = trainControl(
metric = "ROC", index = tmp))
rpartFit <- train(TrainData, TrainClasses,
method = "glm",
metric = "ROC")
?createDataPartition
folds=5
repeats=1
myControl <- trainControl(method='cv', number=folds, repeats=repeats,
returnResamp='none', classProbs=TRUE,
returnData=FALSE, savePredictions=TRUE,
verboseIter=TRUE, allowParallel=TRUE,
summaryFunction=twoClassSummary,
index=createMultiFolds(Y[train], k=folds, times=repeats))
rpartFit <- train(TrainData, TrainClasses,
method = "glm",
metric = "ROC",trControl=myControl)
myControl <- trainControl(method='cv', number=folds, repeats=repeats,
returnResamp='none', classProbs=TRUE,
returnData=FALSE, savePredictions=TRUE,
verboseIter=TRUE, allowParallel=TRUE,
summaryFunction=twoClassSummary,
index=createMultiFolds(TrainClasses, k=folds, times=repeats))
rpartFit <- train(TrainData, TrainClasses,
method = "glm",
metric = "ROC",trControl=myControl)
str(TrainClasses)
table(TrainClasses)
library(mlbench)
install.packages("mlbench")
library(mlbench)
dat <- mlbench.xor(500, 2)
X <- data.frame(dat$x)
Y <- factor(ifelse(dat$classes=='1', 'Yes', 'No'))
train <- runif(nrow(X)) <= .66
#Setup CV Folds
#returnData=FALSE saves some space
folds=5
repeats=1
Y[train]
createMultiFolds(Y[train], k=folds, times=repeats)
myControl <- trainControl(method='cv', number=folds, repeats=repeats,
returnResamp='none', classProbs=TRUE,
returnData=FALSE, savePredictions=TRUE,
verboseIter=TRUE, allowParallel=TRUE,
summaryFunction=twoClassSummary,
index=createMultiFolds(Y[train], k=folds, times=repeats))
Y[train]
